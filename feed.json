{"title":"Leon","description":"Plodding wins the race","language":["en","zh-Hans","default"],"link":"http://luuil.github.io","pubDate":"Fri, 28 Dec 2018 02:45:53 GMT","lastBuildDate":"Tue, 05 Nov 2019 04:08:05 GMT","generator":"hexo-generator-json-feed","webMaster":"Leon Lau","items":[{"title":"Docker multi-stage builds","link":"http://luuil.github.io/2018/12/28/Docker-multi-stage-builds/","description":"Docker多阶段构建是17.05以后引入的新特性，旨在解决编译和构建复杂、镜像太大的问题。因此要使用多阶段构建特性必须使用高于或等于17.05的Docker。","pubDate":"Fri, 28 Dec 2018 02:45:53 GMT","guid":"http://luuil.github.io/2018/12/28/Docker-multi-stage-builds/","category":"Tutorial"},{"title":"Python: Decorator","link":"http://luuil.github.io/2018/09/19/Python-Decorator/","description":"Python 的修饰器的英文名叫 Decorator, 当你看到这个英文名的时候, 你可能会把其跟 Design Pattern 里的 Decorator 搞混了, 其实这是完全不同的两个东西. 在介绍装饰器之前, 我们先来点直观的认识, 下面一个 Python 修饰器的示例代码 1234567891011121314def tags(tag_name): def tags_decorator(func): def func_wrapper(name): return \"&lt;&#123;0&#125;&gt;&#123;1&#125;&lt;/&#123;0&#125;&gt;\".format(tag_name, func(name)) return func_wrapper return tags_decorator@tags(\"div\")@tags(\"p\")@tags(\"span\")def get_text(name): return \"Hello \" + nameprint(get_text(\"John\")) 运行这段代码时, 会有如下输出 1&lt;div&gt;&lt;p&gt;&lt;span&gt;Hello John&lt;/span&gt;&lt;/p&gt;&lt;/div&gt; 参考: https://www.cnblogs.com/zh605929205/p/7704902.html","pubDate":"Wed, 19 Sep 2018 02:25:46 GMT","guid":"http://luuil.github.io/2018/09/19/Python-Decorator/","category":"Tutorial"},{"title":"Merging Models for TensorFlow Serving","link":"http://luuil.github.io/2018/09/15/Merging-Models-for-TensorFlow-Serving/","description":"This tool can merge TensorFlow frozen models(.pb file) into the same model. The advantage of doing this is that When deploying, you only need to place the updated version of the model(merged model) in the corresponding location without restart the TensorFlow Serving service. Hot switching can be done easily. That is, the service will not be interrupted when updating the model. See more details on GitHub. Usage Put frozen models(.pb file) into ./frozen directory. Add serving information in export_serving_model.py. Set update messages UPDATE_MESSAGE. Define a export(merging) function. Put ServingInfo.export decorator on export function(if not, then this model will not export). Run export_serving_model.py. Copy the serving model ./serving/{version} to your serving model directory on the server, it will be automatically loaded. Call it by RPC, such as gRPC.","pubDate":"Sat, 15 Sep 2018 02:22:30 GMT","guid":"http://luuil.github.io/2018/09/15/Merging-Models-for-TensorFlow-Serving/","category":"Tool"},{"title":"Commonly Used Docker Commands","link":"http://luuil.github.io/2018/09/08/Commonly-Used-Docker-Commands/","description":"常用的 Docker 命令本文集中了一些常用的 Docker 命令, 详细还请查看 官方文档. 查看容器: docker ps 查看镜像: docker images 运行镜像: docker run &lt;IMAGE&gt; 进入容器: docker exec -t -i &lt;CONTAINER&gt; /bin/bash","pubDate":"Sat, 08 Sep 2018 08:21:35 GMT","guid":"http://luuil.github.io/2018/09/08/Commonly-Used-Docker-Commands/","category":"Tutorial"},{"title":"LabelMe-Docker: Online Annotaion Tool Docker Image","link":"http://luuil.github.io/2018/09/07/LabelMe-Docker-Online-Annotaion-Tool-Docker-Image/","description":"LabelMe 是一个用 Javascript 编写的图像标注工具, 可以用于 在线 图像标注. 也就是说, LabelMe 可以部署在服务器, 然后使用浏览器进行访问. 与传统图像标注工具相比, 优势在于可以从任何地方访问该工具, 而且不需要在自己机器上安装或复制整个大型数据集. 它有如下优势 添加待标图片和获取标注结果方便. 降低外包人员招聘成本: 之前需要招聘专职标注人员到公司进行标注, 招聘难度大. 降低标注成本: 因为能够远程标注, 自由度高, 可以适当降低标注价格. 降低标注数据泄露的风险: 待标图片和标注结果均在服务器上.","pubDate":"Fri, 07 Sep 2018 02:58:21 GMT","guid":"http://luuil.github.io/2018/09/07/LabelMe-Docker-Online-Annotaion-Tool-Docker-Image/","category":"Tool"},{"title":"TensorFlow Audio Classification","link":"http://luuil.github.io/2018/09/05/TensorFlow-Audio-Classification/","description":"此项目源自2018年5月公司的一个实际项目: 检测主播是否在唱歌, 即通过直播间的声音信号判定主播当前时间段是否在唱歌. 该项目已于2018年6月20日上线, 准确率为 ~93%. 在此之前, 我没有语音相关的经验, 不仅如此, 公司内部也没有相关技术储备. 只能凭借经验和 sense 去查找解决方案, 经过 1 星期的调研, 确定了使用深度学习, 并选定 特征提取 + 分类 这种比较传统但成熟的方案. 最后, 我与一个实习生经过一个月的努力, 在 deadline 之前完成上线. 具体地 特征提取 阶段选用 VGGish 网络结构, 这是由 Google 开源并在 YouTube8M 中实际应用的技术; 分类 阶段采用非常简单的结构: 2个全连接层 + 1个Softmax层 , 因为 VGGish 提取的特征(embedding)够紧凑, 包含的信息足够多, 可以应对一个二分类问题(唱歌和非唱歌); 在这篇文章中, 我将介绍关于这个项目涉及的主要问题和解决办法, 以及怎样通过一些技巧将准确率从 70% 提升至 93%. 并以一个公开数据集 UrbanSound 作为例子进行讲解. 开源地址: https://github.com/luuil/tensorflow-audio-classification","pubDate":"Wed, 05 Sep 2018 14:46:43 GMT","guid":"http://luuil.github.io/2018/09/05/TensorFlow-Audio-Classification/","category":"Tutorial"},{"title":"Useful Plugins for Hexo","link":"http://luuil.github.io/2018/09/05/Useful-Plugins-for-Hexo/","description":"Useful plugins for Hexo hexo-deployer-git hexo-generator-json-feed hexo-generator-seo-friendly-sitemap hexo-generator-searchdb","pubDate":"Wed, 05 Sep 2018 08:36:10 GMT","guid":"http://luuil.github.io/2018/09/05/Useful-Plugins-for-Hexo/","category":"Tutorial"},{"title":"Github Pages with Hexo","link":"http://luuil.github.io/2018/09/04/Github-Pages-with-Hexo/","description":"Hexo 是一个快速、简洁且高效的博客框架.Hexo 使用 Markdown(或其他渲染引擎)解析文章, 在几秒内, 即可利用靓丽的主题生成静态网页. 简易教程本章主要介绍在使用 hexo 写文章时最常用的步骤, 如果想查看详细的内容可以查看 原始文档 或 下面的 补充内容. 在开始下面内容之前, 默认您已经安装过Hexo及其相关依赖, 并且已经设置好 Github 仓库.如果您还没做过上述操作, 请查看 原始文档 或 下面的 补充内容. 创建文章(存放至source/_posts) 1hexo new [layout] \"&lt;title&gt;\" 上述命令会按照指定的 layout (layout 即模板, 存放于 scaffolds 文件夹中)生成一个简略的文章. 丰富之前创建的简略文章 发布(可集中放在 deploy.sh 中) 123hexo cleanhexo generatehexo deploy 出现异常时, 可以参考 异常","pubDate":"Tue, 04 Sep 2018 12:40:14 GMT","guid":"http://luuil.github.io/2018/09/04/Github-Pages-with-Hexo/","category":"Tutorial"},{"title":"Hello World","link":"http://luuil.github.io/2018/09/03/hello-world/","description":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","pubDate":"Mon, 03 Sep 2018 15:43:58 GMT","guid":"http://luuil.github.io/2018/09/03/hello-world/","category":""}]}