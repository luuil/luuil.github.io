<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Merging Models for TensorFlow Serving]]></title>
    <url>%2F2018%2F09%2F15%2FMerging-Models-for-TensorFlow-Serving%2F</url>
    <content type="text"><![CDATA[This tool can merge TensorFlow frozen models(.pb file) into the same model. The advantage of doing this is that When deploying, you only need to place the updated version of the model(merged model) in the corresponding location without restart the TensorFlow Serving service. Hot switching can be done easily. That is, the service will not be interrupted when updating the model. See more details on GitHub. Usage Put frozen models(.pb file) into ./frozen directory. Add serving information in export_serving_model.py. Set update messages UPDATE_MESSAGE. Define a export(merging) function. Put ServingInfo.export decorator on export function(if not, then this model will not export). Run export_serving_model.py. Copy the serving model ./serving/{version} to your serving model directory on the server, it will be automatically loaded. Call it by RPC, such as gRPC. NoteRun script export_serving_model.py will automaticly generate(or modify) two files under directory ./serving: current_version: Stores the current version and update information. See details. exported_models: Exported models, one model for one line. TestYou do not need to konwn what the hyaudio model is. We just use itto demonstrate the export functionality. We will export the same model two times to simulate the simultaneousexport multiple models. When you export multiple models, you should specify the signature_name input_signature_map output_signature_map parameters. They refer to signature for serving, entry point of the modeland output point of the model respectively. model signature_name input_signature_map output_signature_map frozen location(./frozen) [model description] hyaudio_1 &#39;inputs&#39;:&#39;hyaudio/vggish_input:0&#39; &#39;classes&#39;:&#39;hyaudio/predict_classes:0&#39;, &#39;probs&#39;:&#39;hyaudio/predict_probs:0&#39; audio/hyaudio.pb [model description] hyaudio_2 &#39;inputs&#39;:&#39;hyaudio/vggish_input:0&#39; &#39;classes&#39;:&#39;hyaudio/predict_classes:0&#39;, &#39;probs&#39;:&#39;hyaudio/predict_probs:0&#39; audio/hyaudio.pb You can export same model twice(or more) when give it a different signature_name as shown above. Check the serving modelWe use the SavedModel CLI tool to check our exported models. To show all available SignatureDef keys in a MetaGraphDef. 1saved_model_cli show --dir ./serving/1 --tag_set serve To show all inputs and outputs TensorInfo for a specific SignatureDef, pass in the SignatureDef key to signature_def option. This is very useful when you want to know the tensor key value, dtype and shape of the input tensors for executing the computation graph later. 1saved_model_cli show --dir ./serving/1 --tag_set serve --signature_def hyaudio_1]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>TensorFlow</tag>
        <tag>TensorFlow Serving</tag>
        <tag>Model</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Commonly Used Docker Commands]]></title>
    <url>%2F2018%2F09%2F08%2FCommonly-Used-Docker-Commands%2F</url>
    <content type="text"><![CDATA[常用的 Docker 命令本文集中了一些常用的 Docker 命令, 详细还请查看 官方文档. 查看容器: docker ps 查看镜像: docker images 运行镜像: docker run &lt;IMAGE&gt; 进入容器: docker exec -t -i &lt;CONTAINER&gt; /bin/bash 查看本地容器1docker ps docker ps 查看本地镜像1docker images docker images 运行镜像: 物理机映射到容器1docker run -v /local/path:/inner/path -d -i -t &lt;IMAGE&gt; 如 1docker run -v /home/luuil:/luuil -dit ubuntu:latest docker run 进入指定容器形式 1docker exec -it &lt;CONTAINER&gt; /bin/bash 如 1docker exec -it 5cb8d5b22575 /bin/bash docker exec 高级命令更不常用的那些命令. 运行 NVIDIA DOCKER, 并指定使用的GPU1docker run --runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=0,1 --rm nvidia/cuda nvidia-smi docker run nvidia docker run 创建及发布镜像(私有仓库)123docker build -t &lt;IMAGE&gt; -f &lt;Dockerfile&gt; .docker tag &lt;SOURCE_IMAGE&gt;[:TAG] &lt;TARGET_IMAGE&gt;[:TAG]docker push NAME[:TAG] 如 123docker build -t src-image -f Dockerfile ..docker tag src-image:latest registry-host:5000/myadmin/tgt-image:latestdocker push registry-host:5000/myadmin/tgt-image:latest docker build docker tag docker push 将变更后的镜像保存: docker commit1docker commit -m &quot;commit message&quot; &lt;CONTAINER&gt; [REPOSITORY[:TAG]] docker commit 根据 Dockerfile 创建镜像: docker build1docker build -t &quot;test_image:latest&quot; . docker build 异常状况下面内容属于容器异常时的一些解决办法. 停止 Restarting 状态的容器1docker update --restart=no &lt;CONTAINER&gt; docker update]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LabelMe-Docker: Online Annotaion Tool Docker Image]]></title>
    <url>%2F2018%2F09%2F07%2FLabelMe-Docker-Online-Annotaion-Tool-Docker-Image%2F</url>
    <content type="text"><![CDATA[LabelMe 是一个用 Javascript 编写的图像标注工具, 可以用于 在线 图像标注. 也就是说, LabelMe 可以部署在服务器, 然后使用浏览器进行访问. 与传统图像标注工具相比, 优势在于可以从任何地方访问该工具, 而且不需要在自己机器上安装或复制整个大型数据集. 它有如下优势 添加待标图片和获取标注结果方便. 降低外包人员招聘成本: 之前需要招聘专职标注人员到公司进行标注, 招聘难度大. 降低标注成本: 因为能够远程标注, 自由度高, 可以适当降低标注价格. 降低标注数据泄露的风险: 待标图片和标注结果均在服务器上. 简易教程这里我们假设在本地已经创建了 labelme-web 镜像(如未创建, 请按后两节进行创建),则运行下列命令即可部署在本地(这里涉及到 Docker, 可以参考本站文章 Commonly Used Docker Commands): 123sudo docker run -dit -p 1080:80 \-v /home/luuil/labelme/Images:/var/www/html/Images \labelme-web:latest 其中 /home/luuil/labelme 可替换为您自己的目录. 我们将 Images 文件夹映射到本地, 是为了更好地 添加 待标图片. 添加待标注图片如果要添加新的待标注图片(LabelMe限制 必须为.jpg格式), 则进行如下操作: 在 /home/luuil/labelme/Images 中新建文件夹, 比如 example 将图片数据放入 /home/huya/labelme/Images/example 使用浏览器访问 http://127.0.0.1:1080/tool.html?mode=f&amp;folder=example 获取标注结果如果想要 获取 标注结果 , 需要先进入 Docker, 检查三个结果文件夹 /var/www/html/Annotations /var/www/html/Masks /var/www/html/Scribbles 不需要进入容器, 而快速从 Docker 容器内拷贝上述文件夹至本地的 当前文件夹 的方式为: 123 sudo docker cp &lt;container_id&gt;:/var/www/html/Annotations . \&amp;&amp; sudo docker cp &lt;container_id&gt;:/var/www/html/Masks . \&amp;&amp; sudo docker cp &lt;container_id&gt;:/var/www/html/Scribbles . &lt;container_id&gt; 为部署容器的 ID. 根据不同的标注方法, 可以在 Annotations, Masks 和 Scribbles 等文件夹中找到我们想要的结果, 具体有何区别, 待读者自己探索:). Docker使用第三节中的 Dockerfile, 创建一个 LabelMe Docker image. 随后, 直接运行镜像即可. 创建1sudo docker build -t "labelme-web" . 运行镜像(即创建容器)123sudo docker run -dit -p 1080:80 \-v /home/luuil/labelme/Images:/var/www/html/Images \labelme-web:latest Dockerfile1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# labelme Dockerfile# base imageFROM ubuntu:14.04.5# install dependenciesRUN apt-get -y updateRUN apt-get install dialog apt-utils -yRUN apt-get install -y --no-install-recommends \ build-essential \ git \ apache2 \ php5 \ libapache2-mod-perl2 \ libapache2-mod-php5# clean upRUN apt-get clean \ &amp;&amp; rm -rf /var/lib/apt/lists/* \ &amp;&amp; rm /var/log/dpkg.log# apache2 configurationRUN a2enmod includeRUN a2enmod rewriteRUN a2enmod cgiRUN update-rc.d apache2 defaults# confd apache2 configurationRUN rm /etc/apache2/sites-enabled/000-default.confADD ubuntu.conf /etc/apache2/sites-enabled/000-default.conf# configure environmentENV LANG=CENV APACHE_LOCK_DIR /var/lock/apache2ENV APACHE_RUN_DIR /var/run/apache2ENV APACHE_PID_FILE $&#123;APACHE_RUN_DIR&#125;/apache2.pidENV APACHE_LOG_DIR /var/log/apache2ENV APACHE_RUN_USER www-dataENV APACHE_RUN_GROUP www-dataENV APACHE_MAX_REQUEST_WORKERS 32ENV APACHE_MAX_CONNECTIONS_PER_CHILD 1024ENV APACHE_ALLOW_OVERRIDE NoneENV APACHE_ALLOW_ENCODED_SLASHES Off# deploy repoRUN cd /var/www/ \ &amp;&amp; rm -rf html \ &amp;&amp; git clone https://github.com/CSAILVision/LabelMeAnnotationTool.git html \ &amp;&amp; cd html \ &amp;&amp; make \ &amp;&amp; chown -R $&#123;APACHE_RUN_USER&#125;:$&#123;APACHE_RUN_GROUP&#125; /var/www# port bindingEXPOSE 80# runCMD ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"] 源码请参照官方: Github: LabelMeAnnotationTool 后记我在空闲时间调研和探索了该工具的用法, 参照文档创建 docker 镜像并推送至公司仓库。 在该工具调研之后的 4 个月得到了团队的应用, 现已部署在私有服务器, 可以给外包人员远程进行标注使用. 截止目前(2018年9月), 已有 1 个项目(背景分割) 和 10 个标注人员使用该工具共标注了 ~7000 张图片,结果显示误标率较低, 约 3/1000, 且多数情况为误操作.]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>LabelMe</tag>
        <tag>Image Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Useful Plugins for Hexo]]></title>
    <url>%2F2018%2F09%2F05%2FUseful-Plugins-for-Hexo%2F</url>
    <content type="text"><![CDATA[Useful plugins for Hexo hexo-deployer-git hexo-generator-json-feed hexo-generator-seo-friendly-sitemap hexo-generator-searchdb hexo-deployer-gitGit deployer plugin for Hexo. 1npm install hexo-deployer-git --save in _config.yml 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git branch: master hexo-generator-json-feedHexo plugin to generate a JSON file similar to RSS feed channel structure with posts contents for generic use or consumption. 1npm i -S hexo-generator-json-feed in _config.yml 123# Json feedjsonFeed: limit: 25 hexo-generator-seo-friendly-sitemapGenerate SEO-friendly sitemap. Inspired by XML Sitemap in Yoast Wordpress SEO Plugin (https://yoast.com). It will generate separated sitemap files for pages, posts, categories, tags and a XSL stylesheet. 1npm install hexo-generator-seo-friendly-sitemap --save in _config.yml 1234sitemap: path: sitemap.xml tag: true category: true hexo-generator-searchdbGenerate search data for Hexo 3.0. This plugin is used for generating a search index file, which contains all the neccessary data of your articles that you can use to write a local search engine for your blog. Supports both XML and JSON format output. 1npm install hexo-generator-searchdb --save in _config.yml 12345search: path: search.xml field: post format: html limit: 10000 See More: Hexo plugins.]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages with Hexo]]></title>
    <url>%2F2018%2F09%2F04%2FGithub-Pages-with-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架.Hexo 使用 Markdown(或其他渲染引擎)解析文章, 在几秒内, 即可利用靓丽的主题生成静态网页. 简易教程本章主要介绍在使用 hexo 写文章时最常用的步骤, 如果想查看详细的内容可以查看 原始文档 或 下面的 补充内容. 在开始下面内容之前, 默认您已经安装过Hexo及其相关依赖, 并且已经设置好 Github 仓库.如果您还没做过上述操作, 请查看 原始文档 或 下面的 补充内容. 创建文章(存放至source/_posts) 1hexo new [layout] "&lt;title&gt;" 上述命令会按照指定的 layout (layout 即模板, 存放于 scaffolds 文件夹中)生成一个简略的文章. 丰富之前创建的简略文章 发布(可集中放在 deploy.sh 中) 123hexo cleanhexo generatehexo deploy 出现异常时, 可以参考 异常 补充内容本章包含的是一般在初次使用时才会用到的内容, 或者一些内容的详细介绍. 安装安装只需要几分钟, 遇到问题可以在此提交, 原版请查看这里. 前提 Node.js Git 然后使用下列 npm(随 Node.js 一同发布的包管理工具) 命令即可安装Hexo. 1npm install -g hexo-cli 如果上述命令运行失败, 则重新启动命令行窗口再运行上述命令即可 建站执行下列命令, Hexo 将会在指定文件夹中新建所需要的文件 123hexo init &#123;folder&#125;cd &#123;folder&#125;npm install 新建完成后, 指定文件夹 {folder} 目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息, 您可以在此配置大部分的参数. package.json应用程序的信息. EJS, Stylus 和 Markdown renderer 已默认安装, 您可以自由移除. 12345678910111213141516171819&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "" &#125;, "dependencies": &#123; "hexo": "^3.0.0", "hexo-generator-archive": "^0.1.0", "hexo-generator-category": "^0.1.0", "hexo-generator-index": "^0.1.0", "hexo-generator-tag": "^0.1.0", "hexo-renderer-ejs": "^0.1.0", "hexo-renderer-stylus": "^0.2.0", "hexo-renderer-marked": "^0.2.4", "hexo-server": "^0.1.2" &#125;&#125; scaffolds模版 文件夹. 当您新建文章时, Hexo 会根据 scaffold 来建立文件. Hexo的模板是指在新建的markdown文件中默认填充的内容. 例如, 如果您修改 scaffold/post.md 中的 Front-matter 内容,那么每次新建一篇文章时都会包含这个修改. source资源文件夹是存放用户资源的地方. 除 _posts 文件夹之外, 开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略.Markdown 和 HTML 文件会被解析并放到 public 文件夹, 而其他文件会被拷贝过去. themes主题 文件夹. Hexo 会根据主题来生成静态页面. 比如, 安装一个新主题(首先要进入到hexo文件夹) 1git clone https://github.com/theme-next/hexo-theme-next themes/next 然后修改_config.yml 1theme: next 想要个性化更多时, 可以编辑 themes/next/_config.yml. 比如想显示更多菜单, 取消相应的注释, 并在 source 文件夹中添加相应的文件夹及 index.md. 123456menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 想显示头像, 则修改 avatar 部分 12345avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /avatar.gif #/images/avatar.gif 安装server1npm install hexo-server --save 安装完成后, 输入以下命令以启动服务器, 您的网站会在 http://localhost:4000 下启动. 在服务器启动期间, Hexo 会监视文件变动并自动更新, 您无须重启服务器. 1hexo server 如果您想要更改端口, 或是在执行时遇到了 EADDRINUSE 错误, 可以在执行时使用 -p 选项指定其他端口, 如下： 1hexo server -p 5000 静态模式在静态模式下, 服务器只处理 public 文件夹内的文件, 而不会处理文件变动, 在执行时, 您应该先自行执行 hexo generate, 此模式通常用于生产环境（production mode）下. 1hexo server -s 自定义 IP服务器默认运行在 0.0.0.0, 您可以覆盖默认的 IP 设置, 如下： 1hexo server -i 192.168.1.1 指定这个参数后, 您就只能通过该IP才能访问站点. 例如, 对于一台使用无线网络的笔记本电脑, 除了指向本机的127.0.0.1外, 通常还有一个192.168.*.*的局域网IP, 如果像上面那样使用-i参数, 就不能用127.0.0.1来访问站点了. 对于有公网IP的主机, 如果您指定一个局域网IP作为-i参数的值, 那么就无法通过公网来访问站点. 写作执行下列命令来创建一篇新文章. 1hexo new [layout] &#123;title&#125; 您可以在命令中指定文章的布局（layout）, 默认为 post, 可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局. 布局(Layout)Hexo 有三种默认布局: post, page 和 draft, 它们分别对应不同的路径, 而您自定义的其他布局和 post 相同, 都将储存到 source/_posts 文件夹. 布局 路径 post source/_posts page source draft source/_drafts 不要处理我的文章 如果你不想你的文章被处理(不发布), 你可以将 Front-Matter 中的 layout: 设为 false . 文件名称Hexo 默认以标题做为文件名称, 但您可编辑 new_post_name 参数来改变默认的文件名称, 举例来说, 设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章. 变量 描述 :title 标题（小写, 空格将会被替换为短杠） :year 建立的年份, 比如, 2015 :month 建立的月份（有前导零）, 比如, 04 :i_month 建立的月份（无前导零）, 比如, 4 :day 建立的日期（有前导零）, 比如, 07 :i_day 建立的日期（无前导零）, 比如, 7 草稿刚刚提到了 Hexo 的一种特殊布局: draft, 这种布局在建立时会被保存到 source/_drafts 文件夹, 您可通过 publish 命令将草稿移动到 source/_posts 文件夹, 该命令的使用方式与 new 十分类似, 您也可在命令中指定 layout 来指定布局. 1hexo publish [layout] &#123;title&#125; 草稿默认不会显示在页面中, 您可在执行时加上 --draft 参数, 或是把 render_drafts 参数设为 true 来预览草稿. 模版(Scaffold)在新建文章时, Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件, 例如： 1hexo new photo "My Gallery" 在执行这行指令时, Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md, 并根据其内容建立文章, 以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 发布Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。 1hexo deploy 在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如： 12deploy: type: git 您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。 12345deploy:- type: git repo:- type: heroku repo: 缩进 YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。 GitGH仓库需要在 Github 中创建一个名为 &lt;username&gt;.github.io 的仓库,用于存放 Github Pages 用到的静态网站文件. 发布配置安装 hexo-deployer-git. 1npm install hexo-deployer-git --save 修改配置. 12345deploy: type: git repo: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git branch: [branch] message: [message] 参数 描述 repo 库（Repository）地址, 将 &lt;username&gt; 替换为您自己的用户名 branch 分支名称. 如果您使用的是 GitHub 或 GitCafe 的话, 程序会尝试自动检测 message 自定义提交信息 (默认为 Site updated: &#39;YYYY-MM-DD HH:mm:ss&#39;s) 如果访问 &lt;username&gt;.github.io 出现404时请到仓库设置https://github.com/&lt;username&gt;/&lt;username&gt;.github.io/settings 中修改主题(Choose a Theme). 发布编写好文章后, 执行下列命令即可发布至GH: 123hexo cleanhexo generatehexo deploy 其他类型的部署可以参照 原文]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
