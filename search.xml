<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker multi-stage builds]]></title>
    <url>%2F2018%2F12%2F28%2FDocker-multi-stage-builds%2F</url>
    <content type="text"><![CDATA[Docker多阶段构建是17.05以后引入的新特性，旨在解决编译和构建复杂、镜像太大的问题。因此要使用多阶段构建特性必须使用高于或等于17.05的Docker。 多阶段构建出现之前构建镜像最具挑战性的一点是使镜像大小尽可能的小。Dockerfile中的每条指令都为图像添加了一个图层，您需要记住在移动到下一层之前清理任何不需要的东西。 为了编写一个真正高效的Dockerfile，传统上需要使用shell技巧和其他逻辑来保持层尽可能小，并确保每个层都具有前一层所需的东西。 实际上，有一个Dockerfile用于开发（包含构建应用程序所需的所有内容），以及用于生产环境的精简版Dockerfile，它只包含您的应用程序以及运行它所需的内容。这被称为“建造者模式”。维护两个Dockerfile并不理想。 这是一个Dockerfile.build和Dockerfile的例子，它遵循上面的模式： Dockerfile.build 12345FROM golang:1.7.3WORKDIR /go/src/github.com/alexellis/href-counter/COPY app.go .RUN go get -d -v golang.org/x/net/html \&amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . 请注意，此示例使用Bash &amp;&amp; 运算符压缩两个RUN命令，以避免在image中创建其他层。这很容易出错并且难以维护。 Dockerfile 12345FROM alpine:latest RUN apk --no-cache add ca-certificatesWORKDIR /root/COPY app .CMD ["./app"] build.sh 12345678910#!/bin/shecho Building alexellis2/href-counter:builddocker build --build-arg https_proxy=$https_proxy --build-arg http_proxy=$http_proxy \-t alexellis2/href-counter:build . -f Dockerfile.builddocker container create --name extract alexellis2/href-counter:build docker container cp extract:/go/src/github.com/alexellis/href-counter/app ./app docker container rm -f extractecho Building alexellis2/href-counter:latestdocker build --no-cache -t alexellis2/href-counter:latest .rm ./app 当您运行build.sh脚本时，它需要构建第一个image，从中创建容器以复制工件，然后构建第二个image。 多阶段构建可以大大简化这种情况. 使用多阶段构建对于多阶段构建，您可以在Dockerfile中使用多个FROM语句。每个FROM指令可以使用不同的基础，并且每个指令都开始一个新的构建。您可以选择性地将工件从一个阶段复制到另一个阶段，从而在最终image中只留下您想要的内容。 为了说明这是如何工作的，让我们调整上述示例的Dockerfile以使用多阶段构建。 Dockerfile 12345678910FROM golang:1.7.3WORKDIR /go/src/github.com/alexellis/href-counter/RUN go get -d -v golang.org/x/net/html COPY app.go .RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .FROM alpine:latest RUN apk --no-cache add ca-certificatesWORKDIR /root/COPY --from=0 /go/src/github.com/alexellis/href-counter/app .CMD ["./app"] 您只需要单个Dockerfile。您也不需要单独的构建脚本。只需运行docker build 1$ docker build -t app:latest . 最终结果是产生与之前相同大小的image，复杂性显著降低。您不需要创建任何中间image，也不需要将任何artifacts提取到本地系统。 它是如何工作的？第二个FROM指令以alpine:latest镜像为基础开始一个新的构建阶段。 COPY –from = 0 行仅将前一阶段的构建文件复制到此新阶段。Go SDK和任何中间层都被遗忘，而不是保存在最终image中。 为多构建阶段命名默认情况下，阶段未命名，您可以通过整数来引用它们，从第0个FROM指令开始。 但是，您可以通过向FROM指令添加as NAME来命名您的阶段。此示例通过命名阶段并使用COPY指令中的名称来改进前一个示例。 这意味着即使稍后重新排序Dockerfile中的指令，COPY也不会中断。 12345678910FROM golang:1.7.3 as builderWORKDIR /go/src/github.com/alexellis/href-counter/RUN go get -d -v golang.org/x/net/html COPY app.go .RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .FROM alpine:latest RUN apk --no-cache add ca-certificatesWORKDIR /root/COPY --from=builder /go/src/github.com/alexellis/href-counter/app .CMD ["./app"] 停在特定的构建阶段构建镜像时，不一定需要构建整个Dockerfile每个阶段。 您可以指定目标构建阶段。以下命令假定您使用的是以前的Dockerfile，但在名为builder的阶段停止： 1$ docker build --target builder -t alexellis2/href-counter:latest . 使用此功能可能的一些非常适合的场景是： 调试特定的构建阶段 在debug阶段，启用所有调试或工具，而在production阶段尽量精简 在testing阶段，您的应用程序将填充测试数据，但在production阶段则使用生产数据 使用外部镜像作为stage使用多阶段构建时，您不仅可以从Dockerfile中创建的镜像中进行复制。 您还可以使用COPY –from指令从单独的image中复制，使用本地image名称，本地或Docker注册表中可用的标记或标记ID。 如有必要，Docker会提取image并从那里开始复制。 1COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf Ref. 官方文档 multistage-build]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Multi-stage builds</tag>
        <tag>Dockerfile</tag>
        <tag>多阶段构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python: Decorator]]></title>
    <url>%2F2018%2F09%2F19%2FPython-Decorator%2F</url>
    <content type="text"><![CDATA[Python 的修饰器的英文名叫 Decorator, 当你看到这个英文名的时候, 你可能会把其跟 Design Pattern 里的 Decorator 搞混了, 其实这是完全不同的两个东西. 在介绍装饰器之前, 我们先来点直观的认识, 下面一个 Python 修饰器的示例代码 1234567891011121314def tags(tag_name): def tags_decorator(func): def func_wrapper(name): return "&lt;&#123;0&#125;&gt;&#123;1&#125;&lt;/&#123;0&#125;&gt;".format(tag_name, func(name)) return func_wrapper return tags_decorator@tags("div")@tags("p")@tags("span")def get_text(name): return "Hello " + nameprint(get_text("John")) 运行这段代码时, 会有如下输出 1&lt;div&gt;&lt;p&gt;&lt;span&gt;Hello John&lt;/span&gt;&lt;/p&gt;&lt;/div&gt; 参考: https://www.cnblogs.com/zh605929205/p/7704902.html 未完待续…]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Decorator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Merging Models for TensorFlow Serving]]></title>
    <url>%2F2018%2F09%2F15%2FMerging-Models-for-TensorFlow-Serving%2F</url>
    <content type="text"><![CDATA[This tool can merge TensorFlow frozen models(.pb file) into the same model. The advantage of doing this is that When deploying, you only need to place the updated version of the model(merged model) in the corresponding location without restart the TensorFlow Serving service. Hot switching can be done easily. That is, the service will not be interrupted when updating the model. See more details on GitHub. Usage Put frozen models(.pb file) into ./frozen directory. Add serving information in export_serving_model.py. Set update messages UPDATE_MESSAGE. Define a export(merging) function. Put ServingInfo.export decorator on export function(if not, then this model will not export). Run export_serving_model.py. Copy the serving model ./serving/{version} to your serving model directory on the server, it will be automatically loaded. Call it by RPC, such as gRPC. NoteRun script export_serving_model.py will automaticly generate(or modify) two files under directory ./serving: current_version: Stores the current version and update information. See details. exported_models: Exported models, one model for one line. TestYou do not need to konwn what the hyaudio model is. We just use itto demonstrate the export functionality. We will export the same model two times to simulate the simultaneousexport multiple models. When you export multiple models, you should specify the signature_name input_signature_map output_signature_map parameters. They refer to signature for serving, entry point of the modeland output point of the model respectively. model signature_name input_signature_map output_signature_map frozen location(./frozen) [model description] hyaudio_1 &#39;inputs&#39;:&#39;hyaudio/vggish_input:0&#39; &#39;classes&#39;:&#39;hyaudio/predict_classes:0&#39;, &#39;probs&#39;:&#39;hyaudio/predict_probs:0&#39; audio/hyaudio.pb [model description] hyaudio_2 &#39;inputs&#39;:&#39;hyaudio/vggish_input:0&#39; &#39;classes&#39;:&#39;hyaudio/predict_classes:0&#39;, &#39;probs&#39;:&#39;hyaudio/predict_probs:0&#39; audio/hyaudio.pb You can export same model twice(or more) when give it a different signature_name as shown above. Check the serving modelWe use the SavedModel CLI tool to check our exported models. To show all available SignatureDef keys in a MetaGraphDef. 1saved_model_cli show --dir ./serving/1 --tag_set serve To show all inputs and outputs TensorInfo for a specific SignatureDef, pass in the SignatureDef key to signature_def option. This is very useful when you want to know the tensor key value, dtype and shape of the input tensors for executing the computation graph later. 1saved_model_cli show --dir ./serving/1 --tag_set serve --signature_def hyaudio_1]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>TensorFlow Serving</tag>
        <tag>TensorFlow</tag>
        <tag>Model</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Commonly Used Docker Commands]]></title>
    <url>%2F2018%2F09%2F08%2FCommonly-Used-Docker-Commands%2F</url>
    <content type="text"><![CDATA[常用的 Docker 命令本文集中了一些常用的 Docker 命令, 详细还请查看 官方文档. 查看容器: docker ps 查看镜像: docker images 运行镜像: docker run &lt;IMAGE&gt; 进入容器: docker exec -t -i &lt;CONTAINER&gt; /bin/bash 查看本地容器1docker ps docker ps 查看本地镜像1docker images docker images 运行镜像: 物理机映射到容器1docker run -v /local/path:/inner/path -d -i -t &lt;IMAGE&gt; 如 1docker run -v /home/luuil:/luuil -dit ubuntu:latest docker run 进入指定容器形式 1docker exec -it &lt;CONTAINER&gt; /bin/bash 如 1docker exec -it 5cb8d5b22575 /bin/bash docker exec 高级命令更不常用的那些命令. 运行 NVIDIA DOCKER, 并指定使用的GPU1docker run --runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=0,1 --rm nvidia/cuda nvidia-smi docker run nvidia docker run 创建及发布镜像(私有仓库)123docker build -t &lt;IMAGE&gt; -f &lt;Dockerfile&gt; .docker tag &lt;SOURCE_IMAGE&gt;[:TAG] &lt;TARGET_IMAGE&gt;[:TAG]docker push NAME[:TAG] 如 123docker build -t src-image -f Dockerfile ..docker tag src-image:latest registry-host:5000/myadmin/tgt-image:latestdocker push registry-host:5000/myadmin/tgt-image:latest docker build docker tag docker push 将变更后的镜像保存: docker commit1docker commit -m &quot;commit message&quot; &lt;CONTAINER&gt; [REPOSITORY[:TAG]] docker commit 根据 Dockerfile 创建镜像: docker build1docker build -t &quot;test_image:latest&quot; . docker build 异常状况下面内容属于容器异常时的一些解决办法. 停止 Restarting 状态的容器1docker update --restart=no &lt;CONTAINER&gt; docker update]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LabelMe-Docker: Online Annotaion Tool Docker Image]]></title>
    <url>%2F2018%2F09%2F07%2FLabelMe-Docker-Online-Annotaion-Tool-Docker-Image%2F</url>
    <content type="text"><![CDATA[LabelMe 是一个用 Javascript 编写的图像标注工具, 可以用于 在线 图像标注. 也就是说, LabelMe 可以部署在服务器, 然后使用浏览器进行访问. 与传统图像标注工具相比, 优势在于可以从任何地方访问该工具, 而且不需要在自己机器上安装或复制整个大型数据集. 它有如下优势 添加待标图片和获取标注结果方便. 降低外包人员招聘成本: 之前需要招聘专职标注人员到公司进行标注, 招聘难度大. 降低标注成本: 因为能够远程标注, 自由度高, 可以适当降低标注价格. 降低标注数据泄露的风险: 待标图片和标注结果均在服务器上. 简易教程这里我们假设在本地已经创建了 labelme-web 镜像(如未创建, 请按后两节进行创建),则运行下列命令即可部署在本地(这里涉及到 Docker, 可以参考本站文章 Commonly Used Docker Commands): 123sudo docker run -dit -p 1080:80 \-v /home/luuil/labelme/Images:/var/www/html/Images \labelme-web:latest 其中 /home/luuil/labelme 可替换为您自己的目录. 我们将 Images 文件夹映射到本地, 是为了更好地 添加 待标图片. 添加待标注图片如果要添加新的待标注图片(LabelMe限制 必须为.jpg格式), 则进行如下操作: 在 /home/luuil/labelme/Images 中新建文件夹, 比如 example 将图片数据放入 /home/huya/labelme/Images/example 使用浏览器访问 http://127.0.0.1:1080/tool.html?mode=f&amp;folder=example 获取标注结果如果想要 获取 标注结果 , 需要先进入 Docker, 检查三个结果文件夹 /var/www/html/Annotations /var/www/html/Masks /var/www/html/Scribbles 不需要进入容器, 而快速从 Docker 容器内拷贝上述文件夹至本地的 当前文件夹 的方式为: 123 sudo docker cp &lt;container_id&gt;:/var/www/html/Annotations . \&amp;&amp; sudo docker cp &lt;container_id&gt;:/var/www/html/Masks . \&amp;&amp; sudo docker cp &lt;container_id&gt;:/var/www/html/Scribbles . &lt;container_id&gt; 为部署容器的 ID. 根据不同的标注方法, 可以在 Annotations, Masks 和 Scribbles 等文件夹中找到我们想要的结果, 具体有何区别, 待读者自己探索:). Docker使用第三节中的 Dockerfile, 创建一个 LabelMe Docker image. 随后, 直接运行镜像即可. 创建1sudo docker build -t "labelme-web" . 运行镜像(即创建容器)123sudo docker run -dit -p 1080:80 \-v /home/luuil/labelme/Images:/var/www/html/Images \labelme-web:latest Dockerfile1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# labelme Dockerfile# base imageFROM ubuntu:14.04.5# install dependenciesRUN apt-get -y updateRUN apt-get install dialog apt-utils -yRUN apt-get install -y --no-install-recommends \ build-essential \ git \ apache2 \ php5 \ libapache2-mod-perl2 \ libapache2-mod-php5# clean upRUN apt-get clean \ &amp;&amp; rm -rf /var/lib/apt/lists/* \ &amp;&amp; rm /var/log/dpkg.log# apache2 configurationRUN a2enmod includeRUN a2enmod rewriteRUN a2enmod cgiRUN update-rc.d apache2 defaults# confd apache2 configurationRUN rm /etc/apache2/sites-enabled/000-default.confADD ubuntu.conf /etc/apache2/sites-enabled/000-default.conf# configure environmentENV LANG=CENV APACHE_LOCK_DIR /var/lock/apache2ENV APACHE_RUN_DIR /var/run/apache2ENV APACHE_PID_FILE $&#123;APACHE_RUN_DIR&#125;/apache2.pidENV APACHE_LOG_DIR /var/log/apache2ENV APACHE_RUN_USER www-dataENV APACHE_RUN_GROUP www-dataENV APACHE_MAX_REQUEST_WORKERS 32ENV APACHE_MAX_CONNECTIONS_PER_CHILD 1024ENV APACHE_ALLOW_OVERRIDE NoneENV APACHE_ALLOW_ENCODED_SLASHES Off# deploy repoRUN cd /var/www/ \ &amp;&amp; rm -rf html \ &amp;&amp; git clone https://github.com/CSAILVision/LabelMeAnnotationTool.git html \ &amp;&amp; cd html \ &amp;&amp; make \ &amp;&amp; chown -R $&#123;APACHE_RUN_USER&#125;:$&#123;APACHE_RUN_GROUP&#125; /var/www# port bindingEXPOSE 80# runCMD ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"] 源码请参照官方: Github: LabelMeAnnotationTool 后记我在空闲时间调研和探索了该工具的用法, 参照文档创建 docker 镜像并推送至公司仓库。 在该工具调研之后的 4 个月得到了团队的应用, 现已部署在私有服务器, 可以给外包人员远程进行标注使用. 截止目前(2018年9月), 已有 1 个项目(背景分割) 和 10 个标注人员使用该工具共标注了 ~7000 张图片,结果显示误标率较低, 约 3/1000, 且多数情况为误操作.]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>LabelMe</tag>
        <tag>Image Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow Audio Classification]]></title>
    <url>%2F2018%2F09%2F05%2FTensorFlow-Audio-Classification%2F</url>
    <content type="text"><![CDATA[此项目源自2018年5月公司的一个实际项目: 检测主播是否在唱歌, 即通过直播间的声音信号判定主播当前时间段是否在唱歌. 该项目已于2018年6月20日上线, 准确率为 ~93%. 在此之前, 我没有语音相关的经验, 不仅如此, 公司内部也没有相关技术储备. 只能凭借经验和 sense 去查找解决方案, 经过 1 星期的调研, 确定了使用深度学习, 并选定 特征提取 + 分类 这种比较传统但成熟的方案. 最后, 我与一个实习生经过一个月的努力, 在 deadline 之前完成上线. 具体地 特征提取 阶段选用 VGGish 网络结构, 这是由 Google 开源并在 YouTube8M 中实际应用的技术; 分类 阶段采用非常简单的结构: 2个全连接层 + 1个Softmax层 , 因为 VGGish 提取的特征(embedding)够紧凑, 包含的信息足够多, 可以应对一个二分类问题(唱歌和非唱歌); 在这篇文章中, 我将介绍关于这个项目涉及的主要问题和解决办法, 以及怎样通过一些技巧将准确率从 70% 提升至 93%. 并以一个公开数据集 UrbanSound 作为例子进行讲解. 开源地址: https://github.com/luuil/tensorflow-audio-classification 前言在一段直播类视频中，聊天(闲聊, 互动)所占时间比重是最大的, 大约80%, 其余20%包括唱歌, 跳舞, 其他等. 所以, 对于比较喜欢听唱歌的观众来讲, 怎样迅速找到 正在唱歌 的片段是一个可以做的需求. 针对该问题, 本文提出了利用深度学习对直播间声音信号进行分类的方案, 下面进行详细介绍. 摘要要解决 是否在唱歌 问题, 有如下两个先决条件 这是一个语音项目, 公司没相关技术储备, 可选择的方法不详. 如何获取语音数据, 并处理. 为了解决上述两个问题, 我们(与实习生)进行了分工, 我调研了语音项目相关的技术, 实习生负责数据的采集的处理. 最后选定 识别方案：VGGish + 简单分类器（自定义）. 数据来源的两个途径： 利用公开数据集做 pre-train：例如 UrbanSound. 抽取视频中的音频作为 finetune 数据来源：标注唱歌部分(时间区间), 训练时会将这些区间进一步拆分为等长的片段. 概述使用场景本文提出的算法, 使用场景如下 识别声音片段是否为 唱歌/其他 状态 算法流程使用深度学习(机器学习)开发时一般分为 训练 和 预测 两个阶段. 训练是指利用算法在已有数据上拟合(学习)出一些规律或法则(模型), 预测是指使用训练生成的模型对新数据进行预测. 训练分为三步: 基于梅尔倒频谱算法, 提取声音片段的特征, 并将其转换成频谱图片. 将频谱图片输入至 VGGish 网络(直接加载已有 checkpoint)进一步提取图形特征(embedding) 将 embedding 输入 简单分类网络 进行训练, 得到分类模型 预测与训练除第三步外完全一致: 先提取声音特征, 然后加载训练好的模型即可获得预测结果. 未完待续…]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>vggish</tag>
        <tag>audioset</tag>
        <tag>audio-classification</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Useful Plugins for Hexo]]></title>
    <url>%2F2018%2F09%2F05%2FUseful-Plugins-for-Hexo%2F</url>
    <content type="text"><![CDATA[Useful plugins for Hexo hexo-deployer-git hexo-generator-json-feed hexo-generator-seo-friendly-sitemap hexo-generator-searchdb hexo-deployer-gitGit deployer plugin for Hexo. 1npm install hexo-deployer-git --save in _config.yml 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git branch: master hexo-generator-json-feedHexo plugin to generate a JSON file similar to RSS feed channel structure with posts contents for generic use or consumption. 1npm i -S hexo-generator-json-feed in _config.yml 123# Json feedjsonFeed: limit: 25 hexo-generator-seo-friendly-sitemapGenerate SEO-friendly sitemap. Inspired by XML Sitemap in Yoast Wordpress SEO Plugin (https://yoast.com). It will generate separated sitemap files for pages, posts, categories, tags and a XSL stylesheet. 1npm install hexo-generator-seo-friendly-sitemap --save in _config.yml 1234sitemap: path: sitemap.xml tag: true category: true hexo-generator-searchdbGenerate search data for Hexo 3.0. This plugin is used for generating a search index file, which contains all the neccessary data of your articles that you can use to write a local search engine for your blog. Supports both XML and JSON format output. 1npm install hexo-generator-searchdb --save in _config.yml 12345search: path: search.xml field: post format: html limit: 10000 See More: Hexo plugins.]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages with Hexo]]></title>
    <url>%2F2018%2F09%2F04%2FGithub-Pages-with-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架.Hexo 使用 Markdown(或其他渲染引擎)解析文章, 在几秒内, 即可利用靓丽的主题生成静态网页. 简易教程本章主要介绍在使用 hexo 写文章时最常用的步骤, 如果想查看详细的内容可以查看 原始文档 或 下面的 补充内容. 在开始下面内容之前, 默认您已经安装过Hexo及其相关依赖, 并且已经设置好 Github 仓库.如果您还没做过上述操作, 请查看 原始文档 或 下面的 补充内容. 创建文章(存放至source/_posts) 1hexo new [layout] "&lt;title&gt;" 上述命令会按照指定的 layout (layout 即模板, 存放于 scaffolds 文件夹中)生成一个简略的文章. 丰富之前创建的简略文章 发布(可集中放在 deploy.sh 中) 123hexo cleanhexo generatehexo deploy 出现异常时, 可以参考 异常 补充内容本章包含的是一般在初次使用时才会用到的内容, 或者一些内容的详细介绍. 安装安装只需要几分钟, 遇到问题可以在此提交, 原版请查看这里. 前提 Node.js Git 然后使用下列 npm(随 Node.js 一同发布的包管理工具) 命令即可安装Hexo. 1npm install -g hexo-cli 如果上述命令运行失败, 则重新启动命令行窗口再运行上述命令即可 建站执行下列命令, Hexo 将会在指定文件夹中新建所需要的文件 123hexo init &#123;folder&#125;cd &#123;folder&#125;npm install 新建完成后, 指定文件夹 {folder} 目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息, 您可以在此配置大部分的参数. package.json应用程序的信息. EJS, Stylus 和 Markdown renderer 已默认安装, 您可以自由移除. 12345678910111213141516171819&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "" &#125;, "dependencies": &#123; "hexo": "^3.0.0", "hexo-generator-archive": "^0.1.0", "hexo-generator-category": "^0.1.0", "hexo-generator-index": "^0.1.0", "hexo-generator-tag": "^0.1.0", "hexo-renderer-ejs": "^0.1.0", "hexo-renderer-stylus": "^0.2.0", "hexo-renderer-marked": "^0.2.4", "hexo-server": "^0.1.2" &#125;&#125; scaffolds模版 文件夹. 当您新建文章时, Hexo 会根据 scaffold 来建立文件. Hexo的模板是指在新建的markdown文件中默认填充的内容. 例如, 如果您修改 scaffold/post.md 中的 Front-matter 内容,那么每次新建一篇文章时都会包含这个修改. source资源文件夹是存放用户资源的地方. 除 _posts 文件夹之外, 开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略.Markdown 和 HTML 文件会被解析并放到 public 文件夹, 而其他文件会被拷贝过去. themes主题 文件夹. Hexo 会根据主题来生成静态页面. 比如, 安装一个新主题(首先要进入到hexo文件夹) 1git clone https://github.com/theme-next/hexo-theme-next themes/next 然后修改_config.yml 1theme: next 想要个性化更多时, 可以编辑 themes/next/_config.yml. 比如想显示更多菜单, 取消相应的注释, 并在 source 文件夹中添加相应的文件夹及 index.md. 123456menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 想显示头像, 则修改 avatar 部分 12345avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /avatar.gif #/images/avatar.gif 安装server1npm install hexo-server --save 安装完成后, 输入以下命令以启动服务器, 您的网站会在 http://localhost:4000 下启动. 在服务器启动期间, Hexo 会监视文件变动并自动更新, 您无须重启服务器. 1hexo server 如果您想要更改端口, 或是在执行时遇到了 EADDRINUSE 错误, 可以在执行时使用 -p 选项指定其他端口, 如下： 1hexo server -p 5000 静态模式在静态模式下, 服务器只处理 public 文件夹内的文件, 而不会处理文件变动, 在执行时, 您应该先自行执行 hexo generate, 此模式通常用于生产环境（production mode）下. 1hexo server -s 自定义 IP服务器默认运行在 0.0.0.0, 您可以覆盖默认的 IP 设置, 如下： 1hexo server -i 192.168.1.1 指定这个参数后, 您就只能通过该IP才能访问站点. 例如, 对于一台使用无线网络的笔记本电脑, 除了指向本机的127.0.0.1外, 通常还有一个192.168.*.*的局域网IP, 如果像上面那样使用-i参数, 就不能用127.0.0.1来访问站点了. 对于有公网IP的主机, 如果您指定一个局域网IP作为-i参数的值, 那么就无法通过公网来访问站点. 写作执行下列命令来创建一篇新文章. 1hexo new [layout] &#123;title&#125; 您可以在命令中指定文章的布局（layout）, 默认为 post, 可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局. 布局(Layout)Hexo 有三种默认布局: post, page 和 draft, 它们分别对应不同的路径, 而您自定义的其他布局和 post 相同, 都将储存到 source/_posts 文件夹. 布局 路径 post source/_posts page source draft source/_drafts 不要处理我的文章 如果你不想你的文章被处理(不发布), 你可以将 Front-Matter 中的 layout: 设为 false . 文件名称Hexo 默认以标题做为文件名称, 但您可编辑 new_post_name 参数来改变默认的文件名称, 举例来说, 设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章. 变量 描述 :title 标题（小写, 空格将会被替换为短杠） :year 建立的年份, 比如, 2015 :month 建立的月份（有前导零）, 比如, 04 :i_month 建立的月份（无前导零）, 比如, 4 :day 建立的日期（有前导零）, 比如, 07 :i_day 建立的日期（无前导零）, 比如, 7 草稿刚刚提到了 Hexo 的一种特殊布局: draft, 这种布局在建立时会被保存到 source/_drafts 文件夹, 您可通过 publish 命令将草稿移动到 source/_posts 文件夹, 该命令的使用方式与 new 十分类似, 您也可在命令中指定 layout 来指定布局. 1hexo publish [layout] &#123;title&#125; 草稿默认不会显示在页面中, 您可在执行时加上 --draft 参数, 或是把 render_drafts 参数设为 true 来预览草稿. 模版(Scaffold)在新建文章时, Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件, 例如： 1hexo new photo "My Gallery" 在执行这行指令时, Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md, 并根据其内容建立文章, 以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 发布Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。 1hexo deploy 在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如： 12deploy: type: git 您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。 12345deploy:- type: git repo:- type: heroku repo: 缩进 YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。 GitGH仓库需要在 Github 中创建一个名为 &lt;username&gt;.github.io 的仓库,用于存放 Github Pages 用到的静态网站文件. 发布配置安装 hexo-deployer-git. 1npm install hexo-deployer-git --save 修改配置. 12345deploy: type: git repo: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git branch: [branch] message: [message] 参数 描述 repo 库（Repository）地址, 将 &lt;username&gt; 替换为您自己的用户名 branch 分支名称. 如果您使用的是 GitHub 或 GitCafe 的话, 程序会尝试自动检测 message 自定义提交信息 (默认为 Site updated: &#39;YYYY-MM-DD HH:mm:ss&#39;s) 如果访问 &lt;username&gt;.github.io 出现404时请到仓库设置https://github.com/&lt;username&gt;/&lt;username&gt;.github.io/settings 中修改主题(Choose a Theme). 发布编写好文章后, 执行下列命令即可发布至GH: 123hexo cleanhexo generatehexo deploy 其他类型的部署可以参照 原文]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
